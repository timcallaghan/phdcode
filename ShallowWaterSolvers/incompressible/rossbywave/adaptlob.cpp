#include "nr.h"

// Macro for evaluating the signum function
DP signum(DP x)
{
	if (x>0.0)
	{
		return 1.0;
	}
	else
	{
		if (x==0.0)
		{
			return 0.0;
		}
		else
		{
			return -1.0;
		}
	}
}

// Recursive funtion used by adaptlob
DP adaptlobstp(DP f(const DP),const DP a,const DP b, const DP fa, const DP fb, const DP is)
{
	/*
	%ADAPTLOBSTP  Recursive function used by ADAPTLOB.
	%
	%   Q = ADAPTLOBSTP('F',A,B,FA,FB,IS,TRACE) tries to
	%   approximate the integral of F(X) from A to B to
	%   an appropriate relative error. The argument 'F' is
	%   a string containing the name of f.  The remaining
	%   arguments are generated by ADAPTLOB or by recursion.
	%
	%   See also ADAPTLOB.

	%   Walter Gautschi, 08/03/98
	*/

	static int termination2;

	DP h = (b-a)/2.0; 
	DP m = (a+b)/2.0;
	DP alpha = sqrt(2.0/3.0); 
	DP beta = 1.0/sqrt(5.0);
	DP mll = m-alpha*h; DP ml=m-beta*h; DP mr=m+beta*h; DP mrr=m+alpha*h;
	Vec_DP x(5);
	x[0] = mll;
	x[1] = ml;
	x[2] = m;
	x[3] = mr;
	x[4] = mrr;
	Vec_DP y(5);
	for (int i=1;i<=5;i++)
	{
		y[i-1] = f(x[i-1]);
	}
	DP fmll=y[0]; DP fml=y[1]; DP fm=y[2]; DP fmr=y[3]; DP fmrr=y[4];
	DP i2 = (h/6.0)*(fa+fb+5.0*(fml+fmr));
	DP i1=(h/1470.0)*(77.0*(fa+fb)+432.0*(fmll+fmrr)+625.0*(fml+fmr)+672.0*fm);
	
	
	if ((is+(i1-i2)==is) || (mll<=a) || (b<=mrr))
	{
		if (((m <= a) || (b<=m)) && (termination2==0))
		{
			NR::nrwarn("Interval contains no more machine numbers. Required tolerance may not be met.");
			termination2 =1;
		}
		return i1;
	}
	else
	return adaptlobstp(f,a,mll,fa,fmll,is)+adaptlobstp(f,mll,ml,fmll,fml,is)+adaptlobstp(f,ml,m,fml,fm,is)+adaptlobstp(f,m,mr,fm,fmr,is)+adaptlobstp(f,mr,mrr,fmr,fmrr,is)+adaptlobstp(f,mrr,b,fmrr,fb,is);
}




DP NR::adaptlob(DP f(const DP),DP const a,DP const b,DP tol)
{
	/*
	This is a c++ reworking of the MATLAB code of
	Walter Gautschi to compute adaptive Guass-Lobatto
	quadrature. It has been specialized in that the
	number of function arguments is fixed. The user can
	easily modify this though.

	%ADAPTLOB  Numerically evaluate integral using adaptive
	%   Lobatto rule.
	%
	%   Q=ADAPTLOB('F',A,B) approximates the integral of
	%   F(X) from A to B to machine precision.  'F' is a
	%   string containing the name of the function. The
	%   function F must return a vector of output values if
	%   given a vector of input values.
	%
	%   Q=ADAPTLOB('F',A,B,TOL) integrates to a relative
	%   error of TOL.
	%
	%   Q=ADAPTLOB('F',A,B,TOL,TRACE) displays the left
	%   end point of the current interval, the interval
	%   length, and the partial integral.
	%
	%   Q=ADAPTLOB('F',A,B,TOL,TRACE,P1,P2,...) allows
	%   coefficients P1, ... to be passed directly to the
	%   function F:  G=F(X,P1,P2,...). To use default values
	%   for TOL or TRACE, one may pass the empty matrix ([]).
	%
	%   See also ADAPTLOBSTP.

	%   Walter Gautschi, 08/03/98
	%   Reference: Gander, Computermathematik, Birkhaeuser, 1992.
	*/

	static int termination2;
	static DP eps = 2.220446049250313e-016;

	// Initialise the termination criteria
	termination2 = 0;
	// Check to see if tol is too small...
	// if so, set it to machine epsilon for the computer.
	// NOTE: This is har coded here for convenience...should use
	// routine to get it once at the top of the code
	if (tol < eps)
	{
		tol = eps;
	}
	// Set up the interval trackers and other variables and weights
	DP m,h,alpha,beta,x1,x2,x3;
	m = (a+b)/2.0; 
	h = (b-a)/2.0;
	alpha = sqrt(2.0/3.0); 
	beta = 1.0/sqrt(5.0);
	x1 = 0.942882415695480; 
	x2 = 0.641853342345781;
	x3 = 0.236383199662150;
	// Set up the 13 points to use in the integration
	Vec_DP x(13);
	x[0]=a;x[1]=m-x1*h;x[2]=m-alpha*h;x[3]=m-x2*h;x[4]=m-beta*h;x[5]=m-x3*h;x[6]=m;
	x[7]=m+x3*h;x[8]=m+beta*h;x[9]=m+x2*h;x[10]=m+alpha*h;x[11]=m+x1*h;x[12]=b;
	// Now set up the vector of values at the 13 points in x
	Vec_DP y(13);
	for (int i=1;i<=13;i++)
	{
		y[i-1]=f(x[i-1]);
	}
	// Perform the integration...first declare variables
	DP fa,fb,i2,i1,is;
	fa = y[0]; 
	fb = y[12];
	i2 = (h/6.0)*(y[0]+y[12]+5.0*(y[4]+y[8]));
	i1 = (h/1470.0)*(77.0*(y[0]+y[12])+432.0*(y[2]+y[10])+625.0*(y[4]+y[8])+672.0*y[6]);
	is = h*(0.0158271919734802*(y[0]+y[12])+0.0942738402188500*(y[1]+y[11])+0.155071987336585*(y[2]+y[10])+0.188821573960182*(y[3]+y[9])+0.199773405226859*(y[4]+y[8])+0.224926465333340*(y[5]+y[7])+0.242611071901408*y[6]);
	// Do error testing
	DP s = signum(is);
	if (s==0)
	{
		s = 1.0;
	}
	DP erri1 = fabs(i1-is);
	DP erri2 = fabs(i2-is);
	DP R = 1.0; 
	if (erri2 != 0.0)
	{
		R=erri1/erri2;
	}
	if (R > 0.0 && R < 1.0)
	{
		tol=tol/R;
	}
	is=s*fabs(is)*tol/eps;
	if (is==0)
	{
		is=b-a;
	}
	// Call the recursive function for the integral
	return adaptlobstp(f,a,b,fa,fb,is);
}
